#!/usr/bin/php
<?php 
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Carmelo San Giovanni (aka Um3ggh1U) & Simone De Gregori (aka Orion)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_PL_wrk.php
 *  version: 1.3
 *
 */
 
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log','/var/log/runeaudio/rune_PL_wrk.log');
// Connect to Redis backend
$redis = new Redis();
$redis->connect('127.0.0.1', 6379);
include('/var/www/app/libs/runeaudio.php');
// reset worker logfile
sysCmd('echo "--------------- start: rune_PL_wrk ---------------" > /var/log/runeaudio/rune_PL_wrk.log');
runelog("WORKER rune_PL_wrk START",'');
$db = 'sqlite:/var/www/db/player.db';
// --- DEMONIZE ---
	$lock = fopen('/run/rune_PL_wrk.pid', 'c+');
	if (!flock($lock, LOCK_EX | LOCK_NB)) {
		die('already running');
	}
	 
	switch ($pid = pcntl_fork()) {
		case -1:
			die('unable to fork');
		case 0: // this is the child process
			break;
		default: // otherwise this is the parent process
			fseek($lock, 0);
			ftruncate($lock, 0);
			fwrite($lock, $pid);
			fflush($lock);
			exit;
	}
	 
	if (posix_setsid() === -1) {
		 die('could not setsid');
	}
	 
	fclose(STDIN);
	fclose(STDOUT);
	fclose(STDERR);

	$stdIn = fopen('/dev/null', 'r'); // set fd/0
	$stdOut = fopen('/dev/null', 'w'); // set fd/1
	$stdErr = fopen('php://stdout', 'w'); // a hack to duplicate fd/1 to 2

	pcntl_signal(SIGTSTP, SIG_IGN);
	pcntl_signal(SIGTTOU, SIG_IGN);
	pcntl_signal(SIGTTIN, SIG_IGN);
	pcntl_signal(SIGHUP, SIG_IGN);
// --- DEMONIZE --- //

// --- WORKER MAIN LOOP --- //
while (1) {
runelog("rune_PL_wrk: open MPD local UNIX socket",'');
$mpd = openMpdSocket('/run/mpd.sock') ;
if (!$mpd) {
// exit script
die();

} else {
$status = _parseStatusResponse(MpdStatus($mpd));
// store next songid in PHP SESSION
$redis->set('nextsongid',$status['nextsongid']);
// store "lastsongid" in PHP SESSION
$redis->set('lastsongid',$status['songid']);
		// check for Ramplay
		if ($redis->get('ramplay') === '1') {
			// check ramplay delete
				// if (!rp_checkPLid($_SESSION['lastsongid'],$mpd)) {
				// rp_deleteFile($_SESSION['lastsongid'],$mpd);
				// }
			// check for CMediaFix
			if ($redis->get('cmediafix') === '1') {
			$redis->set('lastbitdepth',$status['audio']);
			}
		}
		
// idle LOOP
runelog("rune_PL_wrk: enter idle loop",'');
$status = monitorMpdState($mpd);
// idle LOOP

		$redis->set('pl_length',$status['playlistlength']);
		$status = ui_status($mpd,$status);
		// CMediaFix
		if ($redis->get('cmediafix') === '1' && $status['state'] === 'play' ) {
			$status['lastbitdepth'] = $redis->get('lastbitdepth');
				if ($redis->get('lastbitdepth') !== $status['audio']) {
					sendMpdCommand($mpd,'cmediafix');
				}
		}
		
		// Ramplay
		if ($redis->get('ramplay') === '1') {
				// set consume mode ON
				// if ($status['consume'] == 0) {
				// sendMpdCommand($mpd,'consume 1');
				// $status['consume'] = 1;
				// }

			// copy track in /dev/shm
			$path = rp_copyFile($status['nextsongid'],$mpd);
			// exec update mdp locazione ramplay
			rp_updateFolder($mpd);
			// exec addandplay track
			rp_addPlay($path,$mpd,$status['playlistlength']);
		}
		
		// Global Random
		if (($redis->get('globalrandom') === '1') && ($redis->get('lastsongid') != $status['songid']) && ($redis->get('globalrandom_lock') === '0')) {
		$addsong = new globalRandom($status);
		$addsong->start();
		$redis->set('globalrandom_lock', 1);
		} else {
		$redis->set('globalrandom_lock', 0);
		}
		
// unlock session
session_write_close();
// JSON response for GUI
runelog("rune_PL_wrk: ui_render() response",json_encode($status));
ui_render('display',json_encode($status));
//ui_render('display',$status);
runelog("rune_PL_wrk: close MPD local UNIX socket",'');
closeMpdSocket($mpd);
}
// --- WORKER MAIN LOOP --- //
}
?>